package Parser; 
import Semantic.*;
import java.util.*;
import java.io.File;
import Parser.Error.*;
import java.util.HashMap;
import java_cup.runtime.*;
import java.io.IOException;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import Main.AssemblerGenerator;

parser code
{:

    private int GUID;
    private Symbol currentSymbol;
    private Symbol previousSymbol;
    private Boolean generateASMFlag;
    private ArrayList<String> listaErroresSemanticos = new ArrayList<String>();
    private PilaSemantica pila = new PilaSemantica();
    public HashMap<String, RegistroSemantico> tablaSimbolos = new HashMap<String, RegistroSemantico>();
    public AssemblerGenerator assemblerGenerator = new AssemblerGenerator();
    public boolean startDeclarations = true;
    public boolean startText = true;

    public Symbol currentSymbol(){
        return this.currentSymbol;
    }

     public void syntax_error(Symbol s){
        syntaxerrors.add(new SyntaxError(ErrorTypes.UNEXPECTED_ERROR, s.right + 1, s.left + 1));
    }
    public void addError(String error){
            this.listaErroresSemanticos.add(error+" en Linea: "+(previousSymbol.right+1));
    }

    public ArrayList<String> getErroresSemanticos() {
        return this.listaErroresSemanticos;
    }

    private ArrayList<SyntaxError> syntaxerrors = new ArrayList<SyntaxError>();

    @Override
    public String toString() {
        String result = "";

        if (!syntaxerrors.isEmpty()) {
            result += "====== Syntax Errors ======\n";

            for (int i = 0; i < syntaxerrors.size(); i++) {
                SyntaxError error = syntaxerrors.get(i);
                if (!(error.getLine() == 0)) result += error.toString();
            }
        }
        return result;
    }
    public void unrecovered_syntax_error(Symbol s){
        //System.out.println("Error NR de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }
    public void newSyntaxError(ErrorTypes pType) {
        syntaxerrors.add(new SyntaxError(pType, previousSymbol.right + 1, previousSymbol.left + previousSymbol.toString().length()));
    }

    public PilaSemantica getPila() {
        return this.pila;
    }

    public HashMap<String, RegistroSemantico> getTabla() {
        return this.tablaSimbolos;
    }
    public AssemblerGenerator getAssemblerGenerator(){
        return this.assemblerGenerator;
    }

:};

scan with {:
        if (currentSymbol != null) this.previousSymbol = currentSymbol;
        this.currentSymbol = this.getScanner().next_token();
        return currentSymbol;
:};


terminal
        IDENTIFIER_ERROR,
         // RESERVED WORDS
         RESERVED_DATA_TYPE,

         // LITERALS
         LITERAL_HEXA,
         LITERAL_FLOAT,
         LITERAL_OCTAL,
         LITERAL_STRING,
         LITERAL_DECIMAL,
         LITERAL_CHARACTER,
         LITERAL_EXPONENTIAL_FLOAT,

         // OPERATORS
         OPERATOR_INC,
         OPERATOR_DEC,
         OPERATOR_ADD,
         OPERATOR_DIVIDE,
         OPERATOR_BRACKET_L,
         OPERATOR_BRACKET_R,
         OPERATOR_END_LINE,
         OPERATOR_NEGATIVE,
         OPERATOR_SEPARATE,
         OPERATOR_MULTIPLY,
         OPERATOR_REMAINDER,
         OPERATOR_ASSIGNMENT,
         OPERATOR_ASSIGNMENT_EQUALS,
         OPERATOR_SQ_BRACKET_L,
         OPERATOR_SQ_BRACKET_R,
         OPERATOR_PARENTHESIS_L,
         OPERATOR_PARENTHESIS_R,
         OPERATOR_COMPARATIVE,
         OPERATOR_NOT,
         OPERATOR_COLON,
         BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, ELSE, FOR, IF , RETURN, SHORT, SWITCH, VOID, WHILE, READ, WRITE, IDENTIFIER,
         INT, LONG;



non terminal initial;
non terminal valid_name, data_type, typed_identifier, assignments;
non terminal var_declarations, var_declaration, var_expression, var_list_brackets, literals, valid_statement, inc_dec, math;

non terminal func_declarations, func_declaration, func_decl_parentheses, statement, func_call_parentheses, parameter, statements;

non terminal expression, expressions, list_expression, error_terminal_tokens;

non terminal switch, read_write, switch_inside;

non terminal case_expressions, case_expression, assignment_expression;

non terminal switch_data_type, missing_expression, var_identifiers;

non terminal while_expression, while_init, for_expression, if_expression, else_expression, brackets;

non terminal for_variable, loop_words, for_loop;

non terminal var_list_errors, var_list_types;

precedence left OPERATOR_COMPARATIVE;
precedence left OPERATOR_ADD, OPERATOR_NEGATIVE;
precedence left OPERATOR_MULTIPLY, OPERATOR_DIVIDE, OPERATOR_REMAINDER;

precedence left OPERATOR_INC, OPERATOR_DEC;

precedence right IDENTIFIER, IDENTIFIER_ERROR;

start with initial;

initial ::=
    var_declarations func_declarations |
    func_declarations |
    error error_terminal_tokens
;

for_loop ::=
    for_expression brackets |
    for_expression OPERATOR_END_LINE
;

for_expression ::=
    FOR OPERATOR_PARENTHESIS_L for_variable expression OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable valid_name assignments expression OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable expression OPERATOR_END_LINE OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable valid_name assignments expression OPERATOR_END_LINE OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable OPERATOR_END_LINE OPERATOR_PARENTHESIS_R
;

for_variable ::=
    data_type valid_name OPERATOR_ASSIGNMENT_EQUALS expression OPERATOR_END_LINE|
    valid_name OPERATOR_ASSIGNMENT_EQUALS expression OPERATOR_END_LINE|
    valid_name OPERATOR_END_LINE |
    OPERATOR_END_LINE
;

// VARIABLES
var_declarations ::=
    var_declarations var_declaration |
    var_declaration
;

var_declaration ::=
    var_expression  OPERATOR_END_LINE

    {:

        RegistroTipo registro = (RegistroTipo) this.parser.pila.buscarRegistro(Registros.TIPO);
        while(this.parser.pila.peek() != registro) {
            RegistroIdentificador registroActual = (RegistroIdentificador) this.parser.pila.pop();

            if (this.parser.tablaSimbolos.get(registroActual.getToken()) != null) {
                addError("Variable ya definida");
            } else if(registro.getTipo() == DataTypes.VOID) {
                addError("Variable de tipo VOID");
            } else {
                this.parser.tablaSimbolos.put(registroActual.getToken(), new RegistroIdentificador(registro.getTipo(), registroActual.getToken()));

                if (this.parser.startDeclarations) {
                    this.parser.assemblerGenerator.writeAssemblerCode("section .bss");
                    this.parser.startDeclarations = false;
                }

                switch(registro.getTipo()) {
                    case INT:
                        this.parser.assemblerGenerator.writeAssemblerCode("\t" + registroActual.getToken() + " resb 4");
                        break;
                    case LONG:
                        this.parser.assemblerGenerator.writeAssemblerCode("\t" + registroActual.getToken() + " resb 8");
                        break;
                    case CHAR:
                        this.parser.assemblerGenerator.writeAssemblerCode("\t" + registroActual.getToken() + " resb 1");
                        break;
                }
            }

        }
        this.parser.pila.pop();
    :}

    |
    // Errors
    var_expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    error data_type
;



var_expression ::=
    data_type var_identifiers |
    CONST data_type var_identifiers OPERATOR_ASSIGNMENT_EQUALS expression |
    typed_identifier var_list_brackets |
    CONST typed_identifier var_list_brackets  OPERATOR_ASSIGNMENT_EQUALS list_expression
;

var_identifiers ::=
    var_identifiers OPERATOR_SEPARATE valid_name |
    valid_name |
    var_identifiers valid_name {: newSyntaxError(ErrorTypes.MISSING_SEPARATOR); :}
;

var_list_brackets ::=
    OPERATOR_SQ_BRACKET_L LITERAL_DECIMAL OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L var_list_types OPERATOR_SQ_BRACKET_R {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    var_list_errors {: newSyntaxError(ErrorTypes.MISSING_SQUARE_BRACKETS); :}
;

var_list_errors ::=
    OPERATOR_SQ_BRACKET_L LITERAL_DECIMAL |
    OPERATOR_SQ_BRACKET_L |
    OPERATOR_SQ_BRACKET_R |
    LITERAL_DECIMAL OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L var_list_types {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    var_list_types OPERATOR_SQ_BRACKET_L {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :}
;

var_list_types ::=
   LITERAL_FLOAT | LITERAL_STRING | LITERAL_CHARACTER | LITERAL_EXPONENTIAL_FLOAT
;

// FUNCTIONS
func_declarations ::=
    func_declarations func_declaration |
    func_declaration
;

func_declaration ::=
    typed_identifier func_decl_parentheses brackets {:  :}|
    typed_identifier func_decl_parentheses  OPERATOR_END_LINE {:


    :}
;

brackets ::=
    OPERATOR_BRACKET_L var_declarations statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L var_declarations OPERATOR_BRACKET_R
;

statements ::=
    statements statement |
    statement

;

statement  ::=
    valid_statement OPERATOR_END_LINE |
    while_expression |
    for_loop |
    switch |
    if_expression |
    valid_name assignments expression OPERATOR_END_LINE {:
        RegistroSemantico tempObject = (RegistroSemantico) this.parser.pila.pop();
        RegistroOperador rs_op = (RegistroOperador) this.parser.pila.pop();
        DataObject rs_do2;

        if (this.parser.startText) {
            this.parser.assemblerGenerator.writeAssemblerCode("\nsection .text");
            this.parser.startText = false;
        }

        if (tempObject instanceof RegistroIdentificador) {
            RegistroSemantico registroTemporal = this.parser.getTabla().get(tempObject.getToken());
            if (registroTemporal != null) {
                rs_do2 = new DataObject(((RegistroIdentificador) registroTemporal).getTipo(),
                                        tempObject.getToken(),
                                        Integer.toHexString(System.identityHashCode(tempObject)),
                                        true);
            } else {
                rs_do2 = new DataObject(DataTypes.ERROR,
                                        tempObject.getToken(),
                                        Integer.toHexString(System.identityHashCode(tempObject)),
                                        true);
                addError("Variable no definida");
            }
        } else { // Es constante
            rs_do2 = (DataObject) tempObject;
        }

        if (rs_op.getToken().equals("=")) {

            RegistroIdentificador temporal = (RegistroIdentificador) this.parser.getTabla().get(
                            ((RegistroIdentificador) this.parser.pila.pop()).getToken());

            if (temporal != null) {

                DataObject nombreVar = new DataObject(temporal.getTipo(),
                                        temporal.getToken(),
                                        Integer.toHexString(System.identityHashCode(temporal)));


                if (this.parser.getTabla().get(nombreVar.getNombre()) != null) {

                    if (rs_do2.getTipo() == nombreVar.getTipo()) {
                        if (rs_do2.getVariable()) {
                            //TODO - ESCRIBIR EN ASM
                            this.parser.assemblerGenerator.writeAssemblerCode("\t" + "mov ax, [" + rs_do2.getNombre() + "]");
                            this.parser.assemblerGenerator.writeAssemblerCode("\t" + "mov [" + nombreVar.getNombre() + "], ax\n");
                        } else {
                            //TODO - ESCRIBIR EN ASM
                            this.parser.assemblerGenerator.writeAssemblerCode("\t" + "mov ax, " + rs_do2.getValor());
                            this.parser.assemblerGenerator.writeAssemblerCode("\t" + "mov [" + nombreVar.getNombre() + "], ax\n");
                        }

                    } else {
                        addError("Variables de diferente tipo");
                    }
                } else {
                    addError("Variable no declarada");
                }
            } else {
                addError("Variable no declarada");
            }

        } else {
            // Esto es eval binary

            DataObject rs_do1;

            tempObject = (RegistroSemantico) this.parser.pila.pop();

            if (tempObject instanceof RegistroIdentificador) {
                RegistroSemantico registroTemporal = this.parser.getTabla().get(tempObject.getToken());
                if (registroTemporal != null) {
                    rs_do1 = new DataObject(((RegistroIdentificador) registroTemporal).getTipo(),
                                            tempObject.getToken(),
                                            Integer.toHexString(System.identityHashCode(tempObject)),
                                            true);
                } else {
                    rs_do1 = new DataObject(DataTypes.ERROR,
                                            tempObject.getToken(),
                                            Integer.toHexString(System.identityHashCode(tempObject)),
                                            true);
                    addError("Variable no definida");
                }
            } else { // Es constante
                rs_do1 = (DataObject) tempObject;
            }

            this.parser.pila.pop();

            RegistroIdentificador temporal = (RegistroIdentificador) this.parser.getTabla().get(
                                        ((RegistroIdentificador) this.parser.pila.pop()).getToken());

            if (temporal != null) {

                DataObject nombreVar = new DataObject(temporal.getTipo(),
                                        temporal.getToken(),
                                        Integer.toHexString(System.identityHashCode(temporal)),
                                        true);


                if (this.parser.getTabla().get(nombreVar.getNombre()) != null) {


                    if (rs_do2.getTipo() == nombreVar.getTipo() && rs_do1.getTipo() == nombreVar.getTipo()) {


                        if (rs_do2.getTipo() == DataTypes.INT || rs_do2.getTipo() == DataTypes.LONG) {

                            if (rs_do1.getVariable() || rs_do2.getVariable()) {
                                if (rs_do1.getVariable()) {
                                    this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, [" + rs_do1.getNombre() + "]");
                                } else {
                                    this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, " + rs_do1.getValor());
                                }
                                boolean remainder = false;
                                if (rs_do2.getVariable()) {
                                    switch (rs_op.getToken()) {
                                        case "+" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tadd ax, [" + rs_do2.getNombre() + "]");
                                            break;
                                        case "-" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tsub ax, [" + rs_do2.getNombre() + "]");
                                            break;
                                        case "*" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov dx, [" + rs_do2.getNombre() + "]");
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmul dx");
                                            break;
                                        case "/" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, [" + rs_do2.getNombre() + "]");
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tdiv bx");
                                            break;
                                        case "%" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, [" + rs_do2.getNombre() + "]");
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tdiv bx");
                                            remainder = true;
                                            break;
                                    }
                                } else {
                                    switch (rs_op.getToken()) {
                                        case "+" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tadd ax, " + rs_do2.getValor());
                                            break;
                                        case "-" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tsub ax, " + rs_do2.getValor());
                                            break;
                                        case "*" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov dx, " + rs_do2.getValor());
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmul dx");
                                            break;
                                        case "/" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, " + rs_do2.getValor() );
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tdiv bx");
                                            break;
                                        case "%" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, " + rs_do2.getValor());
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tdiv bx");
                                            remainder = true;
                                            break;
                                    }
                                }
                                if (!remainder) {
                                    this.parser.assemblerGenerator.writeAssemblerCode("\tmov [" + nombreVar.getNombre() + "], ax");
                                } else {
                                    this.parser.assemblerGenerator.writeAssemblerCode("\tmov [" + nombreVar.getNombre() + "], dx");
                                }
                            }

                            else {
                                // Constant folding
                                long valor2 = Long.parseLong(rs_do2.getValor());
                                long valor1 = Long.parseLong(rs_do1.getValor());
                                long nuevoValor = 0;
                                switch (rs_op.getToken()) {
                                    case "+" :
                                        nuevoValor = valor1 + valor2;
                                        break;
                                    case "-" :
                                        nuevoValor = valor1 - valor2;
                                        break;
                                    case "*" :
                                        nuevoValor = valor1 * valor2;
                                        break;
                                    case "/" :
                                        nuevoValor = valor1 / valor2;
                                        break;
                                }
                                nombreVar.setValor(Long.toString(nuevoValor));

                                this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, " + nombreVar.getValor());
                                this.parser.assemblerGenerator.writeAssemblerCode("\tmov [" + nombreVar.getNombre() + "], ax");
                            }

                            /*

                            System.out.println("Constant folding: " + nuevoValor);
                            */
                        }
                    } else {
                        addError("Variables de diferente tipo");
                    }

                } else {
                    addError("Variable no declarada");
                }
            } else {
                addError("Variable no declarada");
            }
        }
    :} |
    valid_name OPERATOR_ASSIGNMENT_EQUALS list_expression OPERATOR_END_LINE |
    brackets |
    loop_words OPERATOR_END_LINE |
    RETURN expression OPERATOR_END_LINE |

    // Read | W /if (rs_do1.)rite
    read_write OPERATOR_END_LINE |

    // Errors
    valid_statement {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :}  |
    valid_name assignments expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    loop_words  {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    RETURN expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    read_write {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    error error_terminal_tokens
;

error_terminal_tokens ::=
    OPERATOR_END_LINE |
    OPERATOR_BRACKET_R
;

read_write ::=
   READ OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |
   READ OPERATOR_PARENTHESIS_L valid_name OPERATOR_PARENTHESIS_R |
   WRITE OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R
;

valid_statement ::=
    valid_name func_call_parentheses |
    valid_name inc_dec |
    inc_dec valid_name
;

func_call_parentheses ::=
    OPERATOR_PARENTHESIS_L expressions OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R
;

func_decl_parentheses ::=
    OPERATOR_PARENTHESIS_L parameter OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |

    // Errores
    OPERATOR_PARENTHESIS_L parameter {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :}|
    OPERATOR_PARENTHESIS_L {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :}
;

expressions ::=
    expressions OPERATOR_SEPARATE expression |
    expression
;

parameter ::=
    parameter OPERATOR_SEPARATE typed_identifier |
    typed_identifier |
    CONST typed_identifier |
    literals {: newSyntaxError(ErrorTypes.FUNCTION_DECLARATION_ERROR); :}
;

list_expression ::=
    OPERATOR_BRACKET_L expressions OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R
;

assignments ::=
    OPERATOR_ASSIGNMENT | OPERATOR_ASSIGNMENT_EQUALS:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
;

// El swith puede contener cero o mas cases, y cero o un default
switch ::=
    SWITCH OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R switch_inside |
    SWITCH missing_expression switch_inside
;

switch_inside ::=
    OPERATOR_BRACKET_L case_expressions DEFAULT OPERATOR_COLON expression OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L DEFAULT OPERATOR_COLON expression OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L case_expressions OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R
;

missing_expression ::=
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R {: newSyntaxError(ErrorTypes.MISSING_EXPRESSION); :}
;

//Esto se utiliza para poder tener uno o mas cases dentro del swtich
case_expressions ::=
    case_expressions case_expression |
    case_expression |
    error OPERATOR_END_LINE {: newSyntaxError(ErrorTypes.CASE_ERROR); :}
;

// Esto seria la expresion case del switch, la cual tiene como estructura minima el case, un dato entero o caracter y dos puntos.
// tambien puede traer una expresion y/o break
case_expression ::=
    CASE switch_data_type OPERATOR_COLON var_declarations statements |
    CASE switch_data_type OPERATOR_COLON statements |
    CASE switch_data_type OPERATOR_COLON var_declarations |
    CASE switch_data_type OPERATOR_COLON
;

//case_expression_error ::=
//    CASE OPERATOR_COLON {: newSyntaxError(ErrorTypes.MISSING_EXPRESSION); :} |
//    CASE switch_data_type {: newSyntaxError(ErrorTypes.MISSING_COLON); :}
//    //CASE switch_data_type OPERATOR_COLON var_declarations statements var_declaration {: newSyntaxError(ErrorTypes.VARIABLE_DECLARATION_ERROR); :} |
//    //CASE switch_data_type OPERATOR_COLON statements var_declaration {: newSyntaxError(ErrorTypes.VARIABLE_DECLARATION_ERROR); :}
//;

// Estos son los tipos de datos que maneja el switch, los cuales son numeros decimales y caracteres
switch_data_type ::=
    LITERAL_DECIMAL |
    LITERAL_FLOAT {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_HEXA |
    LITERAL_OCTAL |
    LITERAL_EXPONENTIAL_FLOAT {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_CHARACTER {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_STRING {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :}
;


// WHILE
while_expression ::=
    DO brackets WHILE OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R OPERATOR_END_LINE |
    WHILE OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R OPERATOR_END_LINE
    | WHILE OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets:e {: System.out.println(e); :} |
    // Error
    WHILE missing_expression brackets |
    DO brackets WHILE missing_expression OPERATOR_END_LINE
;

while_init ::=
    WHILE
;

// COMMON PRODUCTIONS
data_type ::=
    LONG {: RegistroTipo registro = new RegistroTipo(DataTypes.LONG); this.parser.pila.push(registro); :}
    | INT {: RegistroTipo registro = new RegistroTipo(DataTypes.INT); this.parser.pila.push(registro); :}
    | SHORT {: RegistroTipo registro = new RegistroTipo(DataTypes.SHORT); this.parser.pila.push(registro); :}
    | CHAR {: RegistroTipo registro = new RegistroTipo(DataTypes.CHAR); this.parser.pila.push(registro); :}
    | VOID {: RegistroTipo registro = new RegistroTipo(DataTypes.VOID); this.parser.pila.push(registro); :}
    | RESERVED_DATA_TYPE {: newSyntaxError(ErrorTypes.NOT_SUPPORTED_DATA_TYPE); :}
;

valid_name ::=
    IDENTIFIER:e {:
        RegistroIdentificador registro = new RegistroIdentificador(DataTypes.UNDETERMINED, e.toString());
        this.parser.pila.push(registro);
    :}
    | IDENTIFIER_ERROR // Recovers from lexical error
;

typed_identifier ::=
    data_type valid_name |
    valid_name {: newSyntaxError(ErrorTypes.MISSING_DATA_TYPE); :}
;

// Construccion del if

if_expression ::=
    IF OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets else_expression |
    IF OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets |

    // Error
    IF missing_expression brackets else_expression |
    IF missing_expression brackets |
    IF {: newSyntaxError(ErrorTypes.INCOMPLETE_EXPRESSION); :}
;

else_expression ::=
    ELSE if_expression |
    ELSE brackets
;

assignment_expression ::=
    valid_name assignments expression |
    expression
;


expression ::=
    // LOGICAL
    OPERATOR_NOT expression |
    expression OPERATOR_COMPARATIVE expression |

    // MATH
    OPERATOR_NEGATIVE expression |

    expression math expression |


    OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R |

    // FINAL
    literals |
    valid_name |
    valid_statement
;

inc_dec ::=
    OPERATOR_INC | OPERATOR_DEC
;

math ::=
    OPERATOR_ADD:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_NEGATIVE:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_MULTIPLY:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_DIVIDE:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_REMAINDER:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
;

literals ::=
    LITERAL_HEXA:e {: DataObject registro = new DataObject(DataTypes.INT, "", e.toString()); this.parser.pila.push(registro); :}
    | LITERAL_OCTAL:e {: DataObject registro = new DataObject(DataTypes.INT, "", e.toString()); this.parser.pila.push(registro); :}
    | LITERAL_STRING:e {: DataObject registro = new DataObject(DataTypes.STRING, "", e.toString()); this.parser.pila.push(registro); :}
    | LITERAL_CHARACTER :e {: DataObject registro = new DataObject(DataTypes.CHAR, "", e.toString()); this.parser.pila.push(registro); :}
    | LITERAL_DECIMAL:e {: DataObject registro = new DataObject(DataTypes.INT, "", e.toString()); this.parser.pila.push(registro); :}
;

loop_words ::=
    BREAK | CONTINUE
;

