package Parser; 
import java.util.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

import Parser.Error.*;

parser code
{:

    private Symbol currentSymbol;
    private Symbol previousSymbol;

    public Symbol getCurrentSymbol(){
        return this.currentSymbol;
    }

     public void syntax_error(Symbol s){
        System.out.println("Error R de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }

    public void unrecovered_syntax_error(Symbol s){
        System.out.println("Error NR de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }

    private ArrayList<SyntaxError> syntaxerrors = new ArrayList<SyntaxError>();

    @Override
    public String toString() {
        String result = "";

        if (!syntaxerrors.isEmpty()) {
            result += "====== Syntax Errors ======\n";

            for (int i = 0; i < syntaxerrors.size(); i++) {
                result += syntaxerrors.get(i).toString();
            }
        }
        return result;
    }

    public void newSyntaxError(ErrorTypes pType) {
        syntaxerrors.add(new SyntaxError(pType, previousSymbol.right + 1, previousSymbol.left + 1));
    }

:};

scan with {:
        if (currentSymbol != null) this.previousSymbol = currentSymbol;
        this.currentSymbol = this.getScanner().next_token();
        return currentSymbol;
:};


terminal STRING_ERROR,
         UNKNOWN_ERROR,
         COMMENTS_ERROR,
         CHARACTER_ERROR,
         IDENTIFIER_ERROR,
         FLOAT_MANY_DOTS_ERROR,

         // RESERVED WORDS
         RESERVED_LOOP,
         RESERVED_ENUM,
         RESERVED_WORDS,
         RESERVED_MODIFIER,
         RESERVED_CONDITION,
         RESERVED_DATA_TYPE,

         // LITERALS
         LITERAL_HEXA,
         LITERAL_FLOAT,
         LITERAL_OCTAL,
         LITERAL_STRING,
         LITERAL_DECIMAL,
         LITERAL_CHARACTER,
         LITERAL_EXPONENTIAL_FLOAT,

         // OPERATORS
         OPERATOR_INC,
         OPERATOR_DEC,
         OPERATOR_ADD,
         OPERATOR_DOT,
         OPERATOR_MATH,
         OPERATOR_MEMORY,
         OPERATOR_DIVIDE,
         OPERATOR_BINARY,
         OPERATOR_BRACKET_L,
         OPERATOR_BRACKET_R,
         OPERATOR_BOOLEAN,
         OPERATOR_END_LINE,
         OPERATOR_NEGATIVE,
         OPERATOR_SEPARATE,
         OPERATOR_MULTIPLY,
         OPERATOR_REMAINDER,
         OPERATOR_ASSIGNMENT,
         OPERATOR_ASSIGNMENT_EQUALS,
         OPERATOR_L_SHIFT_EQ,
         OPERATOR_R_SHIFT_EQ,
         OPERATOR_BITWISE_OR,
         OPERATOR_SQ_BRACKET_L,
         OPERATOR_SQ_BRACKET_R,
         OPERATOR_PARENTHESIS_L,
         OPERATOR_PARENTHESIS_R,
         OPERATOR_MULTIPLY_EQ,
         OPERATOR_CONTINUE_LINE,
         OPERATOR_BITWISE_AND,
         OPERATOR_BITWISE_EXCLUSIVE_OR,
         OPERATOR_COMPARATIVE,
         OPERATOR_NOT,
         OPERATOR_COLON,
         BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, ELSE, FOR, IF , RETURN, SHORT, SWITCH, VOID, WHILE, READ, WRITE, IDENTIFIER,
         INT, LONG;



non terminal initial;
non terminal valid_name, data_type, typed_identifier, assignments;
non terminal var_declarations, var_declaration, var_expression, var_list_brackets, literals, valid_statement, inc_dec, math;

non terminal func_declarations, func_declaration, func_decl_parentheses, statement, func_call_parentheses, parameter, statements;

non terminal expression, expressions, list_expression, x2;

non terminal switch, read_write, switch_error;

non terminal case_expressions, case_expression, comparison, assignment_expression, case_expression_error;

non terminal switch_data_type;

non terminal while_expression, for_expression, if_expression, else_expression, brackets;

non terminal for_variable, for_condition, loop_words, for_loop;

non terminal error_detection_parentheses, var_list_errors, var_list_types, brackets_error;

precedence left OPERATOR_COMPARATIVE;
precedence left OPERATOR_ADD, OPERATOR_NEGATIVE;
precedence left OPERATOR_MULTIPLY, OPERATOR_DIVIDE, OPERATOR_REMAINDER;

start with initial;

initial ::=
    var_declarations func_declarations |
    func_declarations
;

for_loop ::=
    for_expression brackets |
    for_expression OPERATOR_END_LINE
;

for_expression ::=
    FOR OPERATOR_PARENTHESIS_L for_variable expression OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable valid_name assignments expression OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable expression OPERATOR_END_LINE OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable valid_name assignments expression OPERATOR_END_LINE OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable OPERATOR_END_LINE OPERATOR_PARENTHESIS_R
;

for_variable ::=
    data_type valid_name OPERATOR_ASSIGNMENT_EQUALS expression OPERATOR_END_LINE|
    valid_name OPERATOR_ASSIGNMENT_EQUALS expression OPERATOR_END_LINE|
    valid_name OPERATOR_END_LINE |
    OPERATOR_END_LINE
;

// VARIABLES
var_declarations ::=
    var_declarations var_declaration |
    var_declaration
;

var_declaration ::=
    var_expression  OPERATOR_END_LINE  |
    // Errors
    var_expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :}
;

var_expression ::=
    typed_identifier |
    CONST typed_identifier OPERATOR_ASSIGNMENT_EQUALS expression |
    typed_identifier var_list_brackets |
    CONST typed_identifier var_list_brackets  OPERATOR_ASSIGNMENT_EQUALS list_expression
;

var_list_brackets ::=
    OPERATOR_SQ_BRACKET_L LITERAL_DECIMAL OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L var_list_types OPERATOR_SQ_BRACKET_R {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    var_list_errors {: newSyntaxError(ErrorTypes.MISSING_SQUARE_BRACKETS); :}
;

var_list_errors ::=
    OPERATOR_SQ_BRACKET_L LITERAL_DECIMAL |
    OPERATOR_SQ_BRACKET_L |
    OPERATOR_SQ_BRACKET_R |
    LITERAL_DECIMAL OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L var_list_types {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    var_list_types OPERATOR_SQ_BRACKET_L {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :}
;

var_list_types ::=
   LITERAL_FLOAT | LITERAL_STRING | LITERAL_CHARACTER | LITERAL_EXPONENTIAL_FLOAT
;

// FUNCTIONS
func_declarations ::=
    func_declarations func_declaration |
    func_declaration
;

func_declaration ::=
    typed_identifier func_decl_parentheses brackets  |
    typed_identifier func_decl_parentheses  OPERATOR_END_LINE  |
    VOID valid_name func_decl_parentheses brackets |
    VOID valid_name func_decl_parentheses  OPERATOR_END_LINE
;

brackets ::=
    OPERATOR_BRACKET_L var_declarations statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L var_declarations OPERATOR_BRACKET_R
;

statements ::=
    statements statement |
    statement
;

statement ::=
    valid_statement OPERATOR_END_LINE |
    while_expression |
    for_loop |
    switch |
    if_expression |
    valid_name assignments expression OPERATOR_END_LINE |
    valid_name OPERATOR_ASSIGNMENT_EQUALS list_expression OPERATOR_END_LINE |
    brackets |
    loop_words OPERATOR_END_LINE |

    // Read | Write
    read_write OPERATOR_END_LINE |

    // Errors
    valid_statement {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :}  |
    valid_name assignments expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :}
;

read_write ::=
   READ OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |
   READ OPERATOR_PARENTHESIS_L valid_name OPERATOR_PARENTHESIS_R |
   WRITE OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R
;

valid_statement ::=
    valid_name func_call_parentheses |
    valid_name inc_dec
;

func_call_parentheses ::=
    OPERATOR_PARENTHESIS_L expressions OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R
;

func_decl_parentheses ::=
    OPERATOR_PARENTHESIS_L parameter OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L {:  :} |
    OPERATOR_PARENTHESIS_R {:  :}
;

expressions ::=
    expressions OPERATOR_SEPARATE expression |
    expression
;

parameter ::=
    parameter OPERATOR_SEPARATE typed_identifier |
    typed_identifier |
    CONST typed_identifier
;

list_expression ::=
    OPERATOR_BRACKET_L expressions OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R
;

assignments ::=
    OPERATOR_ASSIGNMENT | OPERATOR_ASSIGNMENT_EQUALS
;

// El swith puede contener cero o mas cases, y cero o un default
switch ::=
    SWITCH OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R OPERATOR_BRACKET_L case_expressions DEFAULT OPERATOR_COLON expression OPERATOR_BRACKET_R |
    SWITCH OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R OPERATOR_BRACKET_L DEFAULT OPERATOR_COLON expression OPERATOR_BRACKET_R |
    SWITCH OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R OPERATOR_BRACKET_L case_expressions OPERATOR_BRACKET_R |
    SWITCH OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R OPERATOR_BRACKET_L OPERATOR_BRACKET_R |
    SWITCH switch_error
;
//
//switch_error ::=
//    OPERATOR_PARENTHESIS_L switch_data_type {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :} |
//    OPERATOR_PARENTHESIS_L {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :} |
//    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R {: newSyntaxError(ErrorTypes.MISSING_EXPRESSION); :} |
//    SWITCH OPERATOR_PARENTHESIS_L switch_data_type OPERATOR_PARENTHESIS_R OPERATOR_BRACKET_L case_expressions DEFAULT OPERATOR_COLON OPERATOR_BRACKET_R |
//    SWITCH OPERATOR_PARENTHESIS_L switch_data_type OPERATOR_PARENTHESIS_R OPERATOR_BRACKET_L DEFAULT OPERATOR_COLON OPERATOR_BRACKET_R
//;

//Esto se utiliza para poder tener uno o mas cases dentro del swtich
case_expressions ::=
    case_expressions case_expression |
    case_expression

;

// Esto seria la expresion case del switch, la cual tiene como estructura minima el case, un dato entero o caracter y dos puntos.
// tambien puede traer una expresion y/o break
case_expression ::=
    CASE switch_data_type OPERATOR_COLON expression BREAK  OPERATOR_END_LINE  |
    CASE switch_data_type OPERATOR_COLON BREAK  OPERATOR_END_LINE  |
    CASE switch_data_type OPERATOR_COLON expression |
    CASE switch_data_type OPERATOR_COLON |
    case_expression_error
;

case_expression_error ::=
    CASE OPERATOR_COLON {: newSyntaxError(ErrorTypes.MISSING_EXPRESSION); :} |
    CASE switch_data_type
;

// Estos son los tipos de datos que maneja el switch, los cuales son numeros decimales y caracteres
switch_data_type ::=
    LITERAL_DECIMAL |
    LITERAL_CHARACTER {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_STRING {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :}
;


// WHILE
while_expression ::=
    WHILE OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets |
    WHILE OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |
    WHILE error_detection_parentheses {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :}
;

// COMMON PRODUCTIONS
data_type ::=
    LONG | INT | SHORT | CHAR
;

valid_name ::=
    IDENTIFIER | IDENTIFIER_ERROR // Recovers from lexical error
;

typed_identifier ::=
    data_type valid_name |
    valid_name {: newSyntaxError(ErrorTypes.MISSING_DATA_TYPE); :}
;

// Construccion del if

if_expression ::=
    IF OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets else_expression |
    IF OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets |
    IF error_detection_parentheses {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :}

;

else_expression ::=
    ELSE if_expression |
    ELSE brackets
;

assignment_expression ::=
    valid_name assignments expression |
    expression
;


expression ::=
    // LOGICAL
    OPERATOR_NOT expression |
    expression OPERATOR_COMPARATIVE expression |

    // MATH
    OPERATOR_NEGATIVE expression |

    expression math expression |


    OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R |

    // FINAL
    literals |
    valid_name |
    valid_statement
;

inc_dec ::=
    OPERATOR_INC | OPERATOR_DEC
;

math ::=
    OPERATOR_ADD | OPERATOR_NEGATIVE | OPERATOR_MULTIPLY | OPERATOR_DIVIDE | OPERATOR_REMAINDER
;

literals ::=
    LITERAL_HEXA | LITERAL_OCTAL | LITERAL_STRING | LITERAL_DECIMAL | LITERAL_CHARACTER
;

loop_words ::=
    BREAK | CONTINUE
;


error_detection_parentheses ::=
    OPERATOR_PARENTHESIS_L assignment_expression |
    OPERATOR_PARENTHESIS_R
;