package Parser; 
import Semantic.*;
import java.util.*;
import java.io.File;
import Parser.Error.*;
import java.util.HashMap;
import java_cup.runtime.*;
import java.io.IOException;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import Main.AssemblerGenerator;

parser code
{:

    private int GUID;
    private Symbol currentSymbol;
    private Symbol previousSymbol;
    private Boolean generateASMFlag;
    private ArrayList<String> listaErroresSemanticos = new ArrayList<String>();
    private PilaSemantica pila = new PilaSemantica();
    public HashMap<String, RegistroSemantico> tablaSimbolos = new HashMap<String, RegistroSemantico>();
    public AssemblerGenerator assemblerGenerator = new AssemblerGenerator();
    public boolean startDeclarations = true;
    public boolean startText = true;

    public Symbol currentSymbol(){
        return this.currentSymbol;
    }

     public void syntax_error(Symbol s){
        syntaxerrors.add(new SyntaxError(ErrorTypes.UNEXPECTED_ERROR, s.right + 1, s.left + 1));
    }
    public void addError(String error){
            this.listaErroresSemanticos.add(error+" en Linea: "+(previousSymbol.right+1));
    }

    public ArrayList<String> getErroresSemanticos() {
        return this.listaErroresSemanticos;
    }

    private ArrayList<SyntaxError> syntaxerrors = new ArrayList<SyntaxError>();

    @Override
    public String toString() {
        String result = "";

        if (!syntaxerrors.isEmpty()) {
            result += "====== Syntax Errors ======\n";

            for (int i = 0; i < syntaxerrors.size(); i++) {
                SyntaxError error = syntaxerrors.get(i);
                if (!(error.getLine() == 0)) result += error.toString();
            }
        }
        return result;
    }
    public void unrecovered_syntax_error(Symbol s){
        //System.out.println("Error NR de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }
    public void newSyntaxError(ErrorTypes pType) {
        syntaxerrors.add(new SyntaxError(pType, previousSymbol.right + 1, previousSymbol.left + previousSymbol.toString().length()));
    }

    public PilaSemantica getPila() {
        return this.pila;
    }

    public HashMap<String, RegistroSemantico> getTabla() {
        return this.tablaSimbolos;
    }
    public AssemblerGenerator getAssemblerGenerator(){
        return this.assemblerGenerator;
    }

:};

scan with {:
        if (currentSymbol != null) this.previousSymbol = currentSymbol;
        this.currentSymbol = this.getScanner().next_token();
        return currentSymbol;
:};


terminal
        IDENTIFIER_ERROR,
         // RESERVED WORDS
         RESERVED_DATA_TYPE,

         // LITERALS
         LITERAL_HEXA,
         LITERAL_FLOAT,
         LITERAL_OCTAL,
         LITERAL_STRING,
         LITERAL_DECIMAL,
         LITERAL_CHARACTER,
         LITERAL_EXPONENTIAL_FLOAT,

         // OPERATORS
         OPERATOR_INC,
         OPERATOR_DEC,
         OPERATOR_ADD,
         OPERATOR_DIVIDE,
         OPERATOR_BRACKET_L,
         OPERATOR_BRACKET_R,
         OPERATOR_END_LINE,
         OPERATOR_NEGATIVE,
         OPERATOR_SEPARATE,
         OPERATOR_MULTIPLY,
         OPERATOR_REMAINDER,
         OPERATOR_ASSIGNMENT,
         OPERATOR_ASSIGNMENT_EQUALS,
         OPERATOR_SQ_BRACKET_L,
         OPERATOR_SQ_BRACKET_R,
         OPERATOR_PARENTHESIS_L,
         OPERATOR_PARENTHESIS_R,
         OPERATOR_COMPARATIVE,
         OPERATOR_NOT,
         OPERATOR_COLON,
         BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, ELSE, FOR, IF , RETURN, SHORT, SWITCH, VOID, WHILE, READ, WRITE, IDENTIFIER,
         INT, LONG;



non terminal initial;
non terminal valid_name, data_type, typed_identifier, assignments;
non terminal var_declarations, var_declaration, var_expression, var_list_brackets, literals, valid_statement, inc_dec, math;

non terminal func_declarations, func_declaration, func_decl_parentheses, statement, func_call_parentheses, parameter, statements;

non terminal expression, expressions, list_expression, error_terminal_tokens;

non terminal switch, read_write, switch_inside, func_start;

non terminal case_expressions, case_expression, assignment_expression;

non terminal switch_data_type, missing_expression, var_identifiers;

non terminal while_expression, while_init, for_expression, if_expression, if_init, if_exit, else_label, else_expression, brackets;

non terminal while_parenthesis_r, test_if;

non terminal for_variable, loop_words, for_loop;

non terminal var_list_errors, var_list_types;

precedence left OPERATOR_COMPARATIVE;
precedence left OPERATOR_ADD, OPERATOR_NEGATIVE;
precedence left OPERATOR_MULTIPLY, OPERATOR_DIVIDE, OPERATOR_REMAINDER;

precedence left OPERATOR_INC, OPERATOR_DEC;

precedence right IDENTIFIER, IDENTIFIER_ERROR;

start with initial;

initial ::=
    var_declarations  func_declarations |
    func_declarations |
    error error_terminal_tokens
;

for_loop ::=
    for_expression brackets |
    for_expression OPERATOR_END_LINE
;

for_expression ::=
    FOR OPERATOR_PARENTHESIS_L for_variable expression OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable valid_name assignments expression OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable expression OPERATOR_END_LINE OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable valid_name assignments expression OPERATOR_END_LINE OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable OPERATOR_END_LINE OPERATOR_PARENTHESIS_R
;

for_variable ::=
    data_type valid_name OPERATOR_ASSIGNMENT_EQUALS expression OPERATOR_END_LINE|
    valid_name OPERATOR_ASSIGNMENT_EQUALS expression OPERATOR_END_LINE|
    valid_name OPERATOR_END_LINE |
    OPERATOR_END_LINE
;

// VARIABLES
var_declarations ::=
    var_declarations var_declaration |
    var_declaration
;

var_declaration ::=
    var_expression  OPERATOR_END_LINE

    {:

        RegistroTipo registro = (RegistroTipo) this.parser.pila.buscarRegistro(Registros.TIPO);
        while(this.parser.pila.peek() != registro) {
            RegistroIdentificador registroActual = (RegistroIdentificador) this.parser.pila.pop();

            if (this.parser.tablaSimbolos.get(registroActual.getToken()) != null) {
                addError("Variable ya definida");
            } else if(registro.getTipo() == DataTypes.VOID) {
                addError("Variable de tipo VOID");
            } else {
                this.parser.tablaSimbolos.put(registroActual.getToken(), new RegistroIdentificador(registro.getTipo(), registroActual.getToken()));

                if (this.parser.startDeclarations) {
                    this.parser.assemblerGenerator.writeAssemblerCode("section .bss");
                    this.parser.startDeclarations = false;
                }

                switch(registro.getTipo()) {
                    case INT:
                        this.parser.assemblerGenerator.writeAssemblerCode("\t" + registroActual.getToken() + " resb 4");
                        break;
                    case LONG:
                        this.parser.assemblerGenerator.writeAssemblerCode("\t" + registroActual.getToken() + " resb 8");
                        break;
                    case CHAR:
                        this.parser.assemblerGenerator.writeAssemblerCode("\t" + registroActual.getToken() + " resb 1");
                        break;
                }
            }

        }
        this.parser.pila.pop();
    :}

    |
    // Errors
    var_expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    error data_type
;



var_expression ::=
    data_type var_identifiers |
    CONST data_type var_identifiers OPERATOR_ASSIGNMENT_EQUALS expression |
    typed_identifier var_list_brackets |
    CONST typed_identifier var_list_brackets  OPERATOR_ASSIGNMENT_EQUALS list_expression
;

var_identifiers ::=
    var_identifiers OPERATOR_SEPARATE valid_name |
    valid_name |
    var_identifiers valid_name {: newSyntaxError(ErrorTypes.MISSING_SEPARATOR); :}
;

var_list_brackets ::=
    OPERATOR_SQ_BRACKET_L LITERAL_DECIMAL OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L var_list_types OPERATOR_SQ_BRACKET_R {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    var_list_errors {: newSyntaxError(ErrorTypes.MISSING_SQUARE_BRACKETS); :}
;

var_list_errors ::=
    OPERATOR_SQ_BRACKET_L LITERAL_DECIMAL |
    OPERATOR_SQ_BRACKET_L |
    OPERATOR_SQ_BRACKET_R |
    LITERAL_DECIMAL OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L var_list_types {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    var_list_types OPERATOR_SQ_BRACKET_L {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :}
;

var_list_types ::=
   LITERAL_FLOAT | LITERAL_STRING | LITERAL_CHARACTER | LITERAL_EXPONENTIAL_FLOAT
;

// FUNCTIONS
func_declarations ::=
    func_declarations func_declaration |
    func_declaration
;

func_declaration ::=
     func_start brackets |
     func_start OPERATOR_END_LINE
;

func_start ::=
    typed_identifier func_decl_parentheses {:

        ArrayList<RegistroIdentificador> parametros = new ArrayList<RegistroIdentificador>();
        RegistroIdentificador param;
        RegistroTipo tipo;

        while(this.parser.pila.size() > 2) {
             param = (RegistroIdentificador) this.parser.pila.pop();
             tipo = (RegistroTipo) this.parser.pila.pop();

             if(tipo.getTipo() != DataTypes.VOID) {
                 if (this.parser.getTabla().get(param.getToken()) != null) {
                    addError("Variable ya definida");
                 } else {
                    this.parser.getTabla().put(param.getToken(), param);
                 }
                 param.setTipo(tipo.getTipo());
                 parametros.add(0, param);
             } else {
                addError("Tipo de parametro invalido");
             }
        }
        param = (RegistroIdentificador) this.parser.pila.pop();
        tipo = (RegistroTipo) this.parser.pila.pop();
        DataObject funcion = new DataObject(tipo.getTipo(), param.getToken(), "", false, true);
        funcion.setParametros(parametros);
        this.parser.getTabla().put(funcion.getNombre() ,funcion);

        this.parser.assemblerGenerator.writeAssemblerCode(param.getToken() + ":");
     :}
;

func_params ::=

;

brackets ::=
    OPERATOR_BRACKET_L var_declarations statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L var_declarations OPERATOR_BRACKET_R
;

statements ::=
    statements statement |
    statement

;

statement  ::=
    valid_statement OPERATOR_END_LINE |
    while_expression |
    for_loop |
    switch |
    if_expression |
    valid_name assignments expression OPERATOR_END_LINE {:
        RegistroSemantico tempObject = (RegistroSemantico) this.parser.pila.pop();
        RegistroOperador rs_op = (RegistroOperador) this.parser.pila.pop();
            DataObject rs_do2;

        if (tempObject instanceof RegistroIdentificador) {
            RegistroSemantico registroTemporal = this.parser.getTabla().get(tempObject.getToken());
            if (registroTemporal != null) {
                rs_do2 = new DataObject(((RegistroIdentificador) registroTemporal).getTipo(),
                                        tempObject.getToken(),
                                        Integer.toHexString(System.identityHashCode(tempObject)),
                                        true, false);
            } else {
                rs_do2 = new DataObject(DataTypes.ERROR,
                                        tempObject.getToken(),
                                        Integer.toHexString(System.identityHashCode(tempObject)),
                                        true, false);
                addError("Variable no definida");
            }
        } else { // Es constante
            rs_do2 = (DataObject) tempObject;
        }

        if (rs_op.getToken().equals("=")) {

            RegistroIdentificador temporal = (RegistroIdentificador) this.parser.getTabla().get(
                            ((RegistroIdentificador) this.parser.pila.pop()).getToken());

            if (temporal != null) {

                DataObject nombreVar = new DataObject(temporal.getTipo(),
                                        temporal.getToken(),
                                        Integer.toHexString(System.identityHashCode(temporal)));


                if (this.parser.getTabla().get(nombreVar.getNombre()) != null) {

                    if (rs_do2.getTipo() == nombreVar.getTipo()) {
                        if (rs_do2.getVariable()) {
                            //TODO - ESCRIBIR EN ASM
                            this.parser.assemblerGenerator.writeAssemblerCode("\t" + "mov ax, [" + rs_do2.getNombre() + "]");
                            this.parser.assemblerGenerator.writeAssemblerCode("\t" + "mov [" + nombreVar.getNombre() + "], ax\n");
                        } else {
                            //TODO - ESCRIBIR EN ASM
                            this.parser.assemblerGenerator.writeAssemblerCode("\t" + "mov ax, " + rs_do2.getValor());
                            this.parser.assemblerGenerator.writeAssemblerCode("\t" + "mov [" + nombreVar.getNombre() + "], ax\n");
                        }

                    } else {
                        addError("Variables de diferente tipo");
                    }
                } else {
                    addError("Variable no declarada");
                }
            } else {
                addError("Variable no declarada");
            }

        } else {
            // Esto es eval binary

            DataObject rs_do1;

            tempObject = (RegistroSemantico) this.parser.pila.pop();

            if (tempObject instanceof RegistroIdentificador) {
                RegistroSemantico registroTemporal = this.parser.getTabla().get(tempObject.getToken());
                if (registroTemporal != null) {
                    rs_do1 = new DataObject(((RegistroIdentificador) registroTemporal).getTipo(),
                                            tempObject.getToken(),
                                            Integer.toHexString(System.identityHashCode(tempObject)),
                                            true, false);
                } else {
                    rs_do1 = new DataObject(DataTypes.ERROR,
                                            tempObject.getToken(),
                                            Integer.toHexString(System.identityHashCode(tempObject)),
                                            true, false);
                    addError("Variable no definida");
                }
            } else { // Es constante
                rs_do1 = (DataObject) tempObject;
            }

            this.parser.pila.pop();

            RegistroIdentificador temporal = (RegistroIdentificador) this.parser.getTabla().get(
                                        ((RegistroIdentificador) this.parser.pila.pop()).getToken());

            if (temporal != null) {

                DataObject nombreVar = new DataObject(temporal.getTipo(),
                                        temporal.getToken(),
                                        Integer.toHexString(System.identityHashCode(temporal)),
                                        true, false);


                if (this.parser.getTabla().get(nombreVar.getNombre()) != null) {


                    if (rs_do2.getTipo() == nombreVar.getTipo() && rs_do1.getTipo() == nombreVar.getTipo()) {


                        if (rs_do2.getTipo() == DataTypes.INT || rs_do2.getTipo() == DataTypes.LONG) {

                            if (rs_do1.getVariable() || rs_do2.getVariable()) {
                                if (rs_do1.getVariable()) {
                                    this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, [" + rs_do1.getNombre() + "]");
                                } else {
                                    this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, " + rs_do1.getValor());
                                }
                                boolean remainder = false;
                                if (rs_do2.getVariable()) {
                                    switch (rs_op.getToken()) {
                                        case "+" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tadd ax, [" + rs_do2.getNombre() + "]");
                                            break;
                                        case "-" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tsub ax, [" + rs_do2.getNombre() + "]");
                                            break;
                                        case "*" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov dx, [" + rs_do2.getNombre() + "]");
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmul dx");
                                            break;
                                        case "/" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, [" + rs_do2.getNombre() + "]");
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tdiv bx");
                                            break;
                                        case "%" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, [" + rs_do2.getNombre() + "]");
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tdiv bx");
                                            remainder = true;
                                            break;
                                    }
                                } else {
                                    switch (rs_op.getToken()) {
                                        case "+" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tadd ax, " + rs_do2.getValor());
                                            break;
                                        case "-" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tsub ax, " + rs_do2.getValor());
                                            break;
                                        case "*" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov dx, " + rs_do2.getValor());
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmul dx");
                                            break;
                                        case "/" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, " + rs_do2.getValor() );
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tdiv bx");
                                            break;
                                        case "%" :
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, " + rs_do2.getValor());
                                            this.parser.assemblerGenerator.writeAssemblerCode("\tdiv bx");
                                            remainder = true;
                                            break;
                                    }
                                }
                                if (!remainder) {
                                    this.parser.assemblerGenerator.writeAssemblerCode("\tmov [" + nombreVar.getNombre() + "], ax");
                                } else {
                                    this.parser.assemblerGenerator.writeAssemblerCode("\tmov [" + nombreVar.getNombre() + "], dx");
                                }
                            }

                            else {
                                // Constant folding
                                long valor2 = Long.parseLong(rs_do2.getValor());
                                long valor1 = Long.parseLong(rs_do1.getValor());
                                long nuevoValor = 0;
                                switch (rs_op.getToken()) {
                                    case "+" :
                                        nuevoValor = valor1 + valor2;
                                        break;
                                    case "-" :
                                        nuevoValor = valor1 - valor2;
                                        break;
                                    case "*" :
                                        nuevoValor = valor1 * valor2;
                                        break;
                                    case "/" :
                                        nuevoValor = valor1 / valor2;
                                        break;
                                }
                                nombreVar.setValor(Long.toString(nuevoValor));

                                this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, " + nombreVar.getValor());
                                this.parser.assemblerGenerator.writeAssemblerCode("\tmov [" + nombreVar.getNombre() + "], ax");
                            }

                            /*

                            System.out.println("Constant folding: " + nuevoValor);
                            */
                        }
                    } else {
                        addError("Variables de diferente tipo");
                    }

                } else {
                    addError("Variable no declarada");
                }
            } else {
                addError("Variable no declarada");
            }
        }
    :} |
    valid_name OPERATOR_ASSIGNMENT_EQUALS list_expression OPERATOR_END_LINE |
    brackets |
    loop_words OPERATOR_END_LINE |
    RETURN expression OPERATOR_END_LINE |

    // Read | W /if (rs_do1.)rite
    read_write OPERATOR_END_LINE |

    // Errors
    valid_statement {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :}  |
    valid_name assignments expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    loop_words  {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    RETURN expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    read_write {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    error error_terminal_tokens
;

error_terminal_tokens ::=
    OPERATOR_END_LINE |
    OPERATOR_BRACKET_R
;

read_write ::=
   READ OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |
   READ OPERATOR_PARENTHESIS_L valid_name OPERATOR_PARENTHESIS_R |
   WRITE OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R
;

valid_statement ::=
    valid_name func_call_parentheses {:
        RegistroIdentificador idFunction = (RegistroIdentificador) this.parser.pila.get(this.parser.pila.size()-1);
                if(this.parser.getTabla().get(idFunction.getToken()) != null){
                    DataObject function = (DataObject) this.parser.getTabla().get(idFunction.getToken());
                    int cantParamCorrectos = function.getParametros().size();
                    int cantParamPila = this.parser.pila.size()-1;
                    if(cantParamCorrectos == cantParamPila){
                        ArrayList param = function.getParametros();
                        cantParamCorrectos--;
                        while(cantParamCorrectos >= 0){
                          RegistroIdentificador rID = (RegistroIdentificador) param.get(cantParamCorrectos);
                          RegistroSemantico rIDAux =  this.parser.pila.pop();
                          DataObject rs_do;

                          if(rIDAux instanceof RegistroIdentificador) {
                              rIDAux = (RegistroIdentificador) this.parser.getTabla().get(rIDAux.getToken());
                              if(rIDAux==null){
                                addError("Parametro no existe");
                                break;
                              }
                              if(((RegistroIdentificador) rIDAux).getTipo() != rID.getTipo()){
                                addError("Parametros con tipos diferentes");
                                break;
                              }
                          }
                          else{
                            rs_do = (DataObject) rIDAux;
                            if(rs_do!= null && rs_do.getTipo() != rID.getTipo()){
                               addError("Parametros con tipos diferentes");
                               break;
                            }
                          }


                          //Revisamos si el tipo es el mismo

                        cantParamCorrectos--;
                        }
                        this.parser.pila.pop();
                    }
                    else{
                      addError("Cantidad incorrecta de parametros en función '"+function.getNombre()+ "'");
                    }
                }
                else{
                     addError("Variable no definida");
                }
     :} |
    valid_name inc_dec {:
        RegistroOperador op = (RegistroOperador) this.parser.pila.pop();
        RegistroIdentificador id = (RegistroIdentificador) this.parser.pila.pop();


        if (this.parser.getTabla().get(id.getToken()) != null) {

            this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, [" + id.getToken() + "]");

            switch(op.getToken()) {

                case "++":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tinc ax");
                    break;

                case "--":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tdec ax");
                    break;
            }
            this.parser.assemblerGenerator.writeAssemblerCode("\tmov [" + id.getToken() + "], ax\n");

        } else {
            addError("Variable no definida");
        }

    :}|
    inc_dec valid_name {:

        RegistroIdentificador id = (RegistroIdentificador) this.parser.pila.pop();
        RegistroOperador op = (RegistroOperador) this.parser.pila.pop();

        if (this.parser.getTabla().get(id.getToken()) != null) {

            this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, [" + id.getToken() + "]");

            switch(op.getToken()) {

                case "++":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tinc ax");
                    break;

                case "--":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tdec ax");
                    break;
            }
            this.parser.assemblerGenerator.writeAssemblerCode("\tmov [" + id.getToken() + "], ax\n");

        } else {
            addError("Variable no definida");
        }

    :}
;

func_call_parentheses ::=
    OPERATOR_PARENTHESIS_L expressions OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R
;

func_decl_parentheses ::=
    OPERATOR_PARENTHESIS_L parameter OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |

    // Errores
    OPERATOR_PARENTHESIS_L parameter {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :}|
    OPERATOR_PARENTHESIS_L {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :}
;

expressions ::=
    expressions OPERATOR_SEPARATE expression |
    expression
;

parameter ::=
    parameter OPERATOR_SEPARATE typed_identifier |
    typed_identifier |
    CONST typed_identifier |
    literals {: newSyntaxError(ErrorTypes.FUNCTION_DECLARATION_ERROR); :}
;

list_expression ::=
    OPERATOR_BRACKET_L expressions OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R
;

assignments ::=
    OPERATOR_ASSIGNMENT | OPERATOR_ASSIGNMENT_EQUALS:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
;

// El swith puede contener cero o mas cases, y cero o un default
switch ::=
    SWITCH OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R switch_inside |
    SWITCH missing_expression switch_inside
;

switch_inside ::=
    OPERATOR_BRACKET_L case_expressions DEFAULT OPERATOR_COLON expression OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L DEFAULT OPERATOR_COLON expression OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L case_expressions OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R
;

missing_expression ::=
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R {: newSyntaxError(ErrorTypes.MISSING_EXPRESSION); :}
;

//Esto se utiliza para poder tener uno o mas cases dentro del swtich
case_expressions ::=
    case_expressions case_expression |
    case_expression |
    error OPERATOR_END_LINE {: newSyntaxError(ErrorTypes.CASE_ERROR); :}
;

// Esto seria la expresion case del switch, la cual tiene como estructura minima el case, un dato entero o caracter y dos puntos.
// tambien puede traer una expresion y/o break
case_expression ::=
    CASE switch_data_type OPERATOR_COLON var_declarations statements |
    CASE switch_data_type OPERATOR_COLON statements |
    CASE switch_data_type OPERATOR_COLON var_declarations |
    CASE switch_data_type OPERATOR_COLON
;

//case_expression_error ::=
//    CASE OPERATOR_COLON {: newSyntaxError(ErrorTypes.MISSING_EXPRESSION); :} |
//    CASE switch_data_type {: newSyntaxError(ErrorTypes.MISSING_COLON); :}
//    //CASE switch_data_type OPERATOR_COLON var_declarations statements var_declaration {: newSyntaxError(ErrorTypes.VARIABLE_DECLARATION_ERROR); :} |
//    //CASE switch_data_type OPERATOR_COLON statements var_declaration {: newSyntaxError(ErrorTypes.VARIABLE_DECLARATION_ERROR); :}
//;

// Estos son los tipos de datos que maneja el switch, los cuales son numeros decimales y caracteres
switch_data_type ::=
    LITERAL_DECIMAL |
    LITERAL_FLOAT {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_HEXA |
    LITERAL_OCTAL |
    LITERAL_EXPONENTIAL_FLOAT {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_CHARACTER {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_STRING {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :}
;


// WHILE
while_expression ::=
    DO brackets while_init OPERATOR_PARENTHESIS_L assignment_expression while_parenthesis_r OPERATOR_END_LINE

    // Solo estos dos casos importan
    | while_init OPERATOR_PARENTHESIS_L assignment_expression while_parenthesis_r OPERATOR_END_LINE {:
        // #endWhile

        RegistroWhile registroWhile = (RegistroWhile) this.parser.pila.pop();
        this.parser.assemblerGenerator.writeAssemblerCode("\t\tjmp " + registroWhile.getEtiquetaInicio());
        this.parser.assemblerGenerator.writeAssemblerCode("\t" + registroWhile.getEtiquetaSalida() + ":\n");

    :}

    | while_init OPERATOR_PARENTHESIS_L assignment_expression while_parenthesis_r brackets:e {:
        // #endWhile

        RegistroWhile registroWhile = (RegistroWhile) this.parser.pila.pop();
        this.parser.assemblerGenerator.writeAssemblerCode("\t\tjmp " + registroWhile.getEtiquetaInicio());
        this.parser.assemblerGenerator.writeAssemblerCode("\t" + registroWhile.getEtiquetaSalida() + ":");

    :}

    // Error
    | while_init missing_expression brackets
| DO brackets while_init missing_expression OPERATOR_END_LINE
;

while_init ::=
    WHILE {:
         // #startWhile
         String etiquetaInicio = "While_Label" + Integer.toString(this.parser.GUID);
         String etiquetaSalida = "Exit_Label" + Integer.toString(this.parser.GUID);
         this.parser.GUID++;
         RegistroWhile registro = new RegistroWhile(etiquetaInicio, etiquetaSalida);
         this.parser.assemblerGenerator.writeAssemblerCode("\t" + etiquetaInicio + ":");
         this.parser.pila.push(registro);

     :}
;

while_parenthesis_r ::=
    OPERATOR_PARENTHESIS_R {:
        // #testWhile
        RegistroSemantico tempObject2 = this.parser.pila.pop();
        RegistroOperador rs_op = (RegistroOperador)this.parser.pila.pop();
        RegistroSemantico tempObject1 = this.parser.pila.pop();
        RegistroWhile registroWhile = (RegistroWhile) this.parser.pila.pop();
        DataObject rs_do2;
        DataObject rs_do1;
        if (tempObject2 instanceof RegistroIdentificador) {
            RegistroSemantico registroTemporal = this.parser.getTabla().get(tempObject2.getToken());
            if (registroTemporal != null) {
                rs_do2 = new DataObject(((RegistroIdentificador) registroTemporal).getTipo(),
                                        tempObject2.getToken(),
                                        Integer.toHexString(System.identityHashCode(tempObject2)),
                                        true, false);
            } else {
                rs_do2 = new DataObject(DataTypes.ERROR,
                                        tempObject2.getToken(),
                                        Integer.toHexString(System.identityHashCode(tempObject2)),
                                        true, false);
                addError("Variable no definida");
            }
        } else { // Es constante
            rs_do2 = (DataObject) tempObject2;
        }

        if (tempObject1 instanceof RegistroIdentificador) {
            RegistroSemantico registroTemporal = this.parser.getTabla().get(tempObject1.getToken());
            if (registroTemporal != null) {
                rs_do1 = new DataObject(((RegistroIdentificador) registroTemporal).getTipo(),
                                        tempObject1.getToken(),
                                        Integer.toHexString(System.identityHashCode(tempObject1)),
                                        true, false);
            } else {
                rs_do1 = new DataObject(DataTypes.ERROR,
                                        tempObject1.getToken(),
                                        Integer.toHexString(System.identityHashCode(tempObject1)),
                                        true, false);
                addError("Variable no definida");
            }
        } else { // Es constante
            rs_do1 = (DataObject) tempObject1;
        }

        if (rs_do1.getVariable()) {
            this.parser.assemblerGenerator.writeAssemblerCode("\t\tmov ax, [" + rs_do1.getNombre() + "]");
        } else {
            this.parser.assemblerGenerator.writeAssemblerCode("\t\tmov ax, " + rs_do1.getValor());
        }

        if (rs_do2.getVariable()) {
            this.parser.assemblerGenerator.writeAssemblerCode("\t\tmov bx, [" + rs_do2.getNombre() + "]");
        } else {
            this.parser.assemblerGenerator.writeAssemblerCode("\t\tmov bx, " + rs_do2.getValor());
        }


        this.parser.assemblerGenerator.writeAssemblerCode("\t\tcmp ax, bx");

        if (rs_do1.getTipo() == rs_do2.getTipo()) {
            switch (rs_op.getToken()) {
                case "<":
                    this.parser.assemblerGenerator.writeAssemblerCode("\t\tjge " + registroWhile.getEtiquetaSalida());
                    break;
                case ">":
                    this.parser.assemblerGenerator.writeAssemblerCode("\t\tjle " + registroWhile.getEtiquetaSalida());
                    break;
                case "==":
                    this.parser.assemblerGenerator.writeAssemblerCode("\t\tjne " + registroWhile.getEtiquetaSalida());
                    break;
                case "&&":
                    this.parser.assemblerGenerator.writeAssemblerCode("\t\tjz " + registroWhile.getEtiquetaSalida());
                    break;
                case "||":
                    this.parser.assemblerGenerator.writeAssemblerCode("\t\tjz " + registroWhile.getEtiquetaSalida());
                    break;
                case "!=":
                    this.parser.assemblerGenerator.writeAssemblerCode("\t\tje " + registroWhile.getEtiquetaSalida());
                    break;
                case "<=":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tjg " + registroWhile.getEtiquetaSalida());
                    break;
                case ">=":
                    this.parser.assemblerGenerator.writeAssemblerCode("\t\tjl " + registroWhile.getEtiquetaSalida());
                    break;
            }
        } else {
            addError("Comparacion invalida");
        }
        this.parser.pila.push(registroWhile);
    :}
;

// COMMON PRODUCTIONS
data_type ::=
    LONG {: RegistroTipo registro = new RegistroTipo(DataTypes.LONG); this.parser.pila.push(registro); :}
    | INT {: RegistroTipo registro = new RegistroTipo(DataTypes.INT); this.parser.pila.push(registro); :}
    | SHORT {: RegistroTipo registro = new RegistroTipo(DataTypes.SHORT); this.parser.pila.push(registro); :}
    | CHAR {: RegistroTipo registro = new RegistroTipo(DataTypes.CHAR); this.parser.pila.push(registro); :}
    | VOID {: RegistroTipo registro = new RegistroTipo(DataTypes.VOID); this.parser.pila.push(registro); :}
    | RESERVED_DATA_TYPE {: newSyntaxError(ErrorTypes.NOT_SUPPORTED_DATA_TYPE); :}
;

valid_name ::=
    IDENTIFIER:e {:
        RegistroIdentificador registro = new RegistroIdentificador(DataTypes.UNDETERMINED, e.toString());
        this.parser.pila.push(registro);
    :}
    | IDENTIFIER_ERROR // Recovers from lexical error
;

typed_identifier ::=
    data_type valid_name |
    valid_name {: newSyntaxError(ErrorTypes.MISSING_DATA_TYPE); :}
;

// Construccion del if

if_expression ::=
    if_init OPERATOR_PARENTHESIS_L assignment_expression test_if if_exit else_expression  |
    if_init OPERATOR_PARENTHESIS_L assignment_expression test_if if_exit {:
        RegistroIf if_reg = (RegistroIf) this.parser.pila.pop();
        this.parser.assemblerGenerator.writeAssemblerCode(if_reg.getExit_label() + ":");
    :}|

    // Error
    if_init missing_expression brackets else_expression {: newSyntaxError(ErrorTypes.INCOMPLETE_EXPRESSION); :} |
    if_init missing_expression brackets {: newSyntaxError(ErrorTypes.INCOMPLETE_EXPRESSION); :}|
    if_init {: newSyntaxError(ErrorTypes.INCOMPLETE_EXPRESSION); :}
;

test_if ::=
    OPERATOR_PARENTHESIS_R {:
        RegistroSemantico registro2 = this.parser.pila.pop();
        RegistroOperador operador = (RegistroOperador) this.parser.pila.pop();
        RegistroSemantico registro1 = this.parser.pila.pop();
        RegistroIf registro_if = (RegistroIf) this.parser.pila.pop();

        DataObject rs_do2, rs_do1;

        if (registro2 instanceof RegistroIdentificador) {
            RegistroSemantico registroTemporal = this.parser.getTabla().get(registro2.getToken());
            if (registroTemporal != null) {
                rs_do2 = new DataObject(((RegistroIdentificador) registroTemporal).getTipo(),
                                          registro2.getToken(),
                                          Integer.toHexString(System.identityHashCode(registro2)),
                                          true, false);
            } else {
                rs_do2 = new DataObject(DataTypes.ERROR,
                                        registro2.getToken(),
                                        Integer.toHexString(System.identityHashCode(registro2)),
                                        true, false);
                addError("Variable no definida");
            }
        } else { // Es constante
            rs_do2 = (DataObject) registro2;
        }

        if (registro1 instanceof RegistroIdentificador) {
            RegistroSemantico registroTemporal = this.parser.getTabla().get(registro1.getToken());
            if (registroTemporal != null) {
                rs_do1 = new DataObject(((RegistroIdentificador) registroTemporal).getTipo(),
                                         registro1.getToken(),
                                         Integer.toHexString(System.identityHashCode(registro1)),
                                         true, false);
            } else {
                rs_do1 = new DataObject(DataTypes.ERROR,
                                       registro1.getToken(),
                                       Integer.toHexString(System.identityHashCode(registro1)),
                                       true, false);
                addError("Variable no definida");
            }
        } else { // Es constante
            rs_do1 = (DataObject) registro1;
        }

        if (rs_do1.getTipo() == rs_do2.getTipo()) {

            this.parser.assemblerGenerator.writeAssemblerCode(";IF");
            // AX para op2
            if (rs_do2.getVariable()) {
                this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, [" + rs_do2.getNombre() + "]");
            } else {
                this.parser.assemblerGenerator.writeAssemblerCode("\tmov ax, " + rs_do2.getValor());
            }
            // BX para op1
            if (rs_do1.getVariable()) {
                this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, [" + rs_do1.getNombre() + "]");
            } else {
                this.parser.assemblerGenerator.writeAssemblerCode("\tmov bx, " + rs_do1.getValor());
            }

            this.parser.assemblerGenerator.writeAssemblerCode("\tcmp ax, bx");
            // Case de Operador
            switch (operador.getToken()) {
                case "<":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tjge " + registro_if.getElse_label());
                    break;
                case ">":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tjle " + registro_if.getElse_label());
                    break;
                case "==":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tjne " + registro_if.getElse_label());
                    break;
                case "&&":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tjz " + registro_if.getElse_label());
                    break;
                case "||":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tjz " + registro_if.getElse_label());
                    break;
                case "!=":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tje " + registro_if.getElse_label());
                    break;
                case "<=":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tjg " + registro_if.getElse_label());
                    break;
                case ">=":
                    this.parser.assemblerGenerator.writeAssemblerCode("\tjle " + registro_if.getElse_label());
                    break;
            }

            this.parser.pila.push(registro_if);
        } else {
            addError("Comparacion invalida");
        }
:}
;

if_init ::=
    IF {:
        RegistroIf if_register = new RegistroIf(Integer.toString(this.parser.GUID), Integer.toString(this.parser.GUID));
        this.parser.GUID++;
        this.parser.pila.push(if_register);
     :}
;

else_expression ::=
    else_label if_expression {:
        RegistroIf if_reg = (RegistroIf) this.parser.pila.pop();
        this.parser.assemblerGenerator.writeAssemblerCode(if_reg.getExit_label() + ":");
     :} |
    else_label if_exit {:
        RegistroIf if_reg = (RegistroIf) this.parser.pila.pop();
        this.parser.assemblerGenerator.writeAssemblerCode(if_reg.getExit_label() + ":");
    :}
;

if_exit ::=
    brackets {:
        RegistroIf if_reg = (RegistroIf) this.parser.pila.pop();
        this.parser.assemblerGenerator.writeAssemblerCode("\tjmp " + if_reg.getExit_label());
        this.parser.pila.push(if_reg);
    :}
;

else_label ::=
    ELSE {:
        RegistroIf if_reg = (RegistroIf) this.parser.pila.pop();
        this.parser.assemblerGenerator.writeAssemblerCode(if_reg.getElse_label() + ":");
        this.parser.pila.push(if_reg);
    :}
;

assignment_expression ::=
    valid_name assignments expression |
    expression
;


expression ::=
    // LOGICAL
    OPERATOR_NOT expression |
    expression OPERATOR_COMPARATIVE:e expression {:

        // Revisar si expression son variables o numeros
        RegistroSemantico registro2 = this.parser.pila.pop();
        RegistroOperador registroOP = new RegistroOperador(e.toString());
        this.parser.pila.push(registroOP);
        this.parser.pila.push(registro2);
    :}|

    // MATH
    OPERATOR_NEGATIVE expression |

    expression math expression |


    OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R |

    // FINAL
    literals |
    valid_name |
    valid_statement
;

inc_dec ::=
    OPERATOR_INC:e {:
        RegistroOperador op = new RegistroOperador(e.toString());
        this.parser.pila.push(op);
    :}| OPERATOR_DEC:e {:
        RegistroOperador op = new RegistroOperador(e.toString());
        this.parser.pila.push(op);
     :}
;

math ::=
    OPERATOR_ADD:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_NEGATIVE:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_MULTIPLY:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_DIVIDE:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_REMAINDER:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
;

literals ::=
    LITERAL_HEXA:e {: DataObject registro = new DataObject(DataTypes.INT, "", e.toString()); this.parser.pila.push(registro); :}
    | LITERAL_OCTAL:e {: DataObject registro = new DataObject(DataTypes.INT, "", e.toString()); this.parser.pila.push(registro); :}
    | LITERAL_STRING:e {: DataObject registro = new DataObject(DataTypes.STRING, "", e.toString()); this.parser.pila.push(registro); :}
    | LITERAL_CHARACTER :e {: DataObject registro = new DataObject(DataTypes.CHAR, "", e.toString()); this.parser.pila.push(registro); :}
    | LITERAL_DECIMAL:e {: DataObject registro = new DataObject(DataTypes.INT, "", e.toString()); this.parser.pila.push(registro); :}
;

loop_words ::=
    BREAK {:
        try {
            RegistroWhile whileRS = (RegistroWhile) this.parser.pila.get(0);
            this.parser.assemblerGenerator.writeAssemblerCode("jmp " + whileRS.getEtiquetaSalida() + " ;BREAK");
            this.parser.pila.push(whileRS);
            this.parser.pila.pop();
        } catch (Exception e) {
            addError("BREAK Fuera de lugar");
        }
    :}

    | CONTINUE {:
        try {
            RegistroWhile whileRS = (RegistroWhile) this.parser.pila.get(0);
            this.parser.assemblerGenerator.writeAssemblerCode("jmp " + whileRS.getEtiquetaInicio() + " ;CONTINUE");
            this.parser.pila.push(whileRS);
            this.parser.pila.pop();
        } catch (Exception e) {
            addError("CONTINUE Fuera de lugar");
        }

    :}
;

