package Parser; 
import java_cup.runtime.Symbol;

parser code
{:
    /*
    private Symbol s;

    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
    }
    */
     public void syntax_error(Symbol s){
        System.out.println("Error R de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }

    public void unrecovered_syntax_error(Symbol s){
        System.out.println("Error NR de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }
:};


terminal STRING_ERROR,
         UNKNOWN_ERROR,
         COMMENTS_ERROR,
         CHARACTER_ERROR,
         IDENTIFIER_ERROR,
         FLOAT_MANY_DOTS_ERROR,

         // RESERVED WORDS
         RESERVED_LOOP,
         RESERVED_ENUM,
         RESERVED_WORDS,
         RESERVED_MODIFIER,
         RESERVED_CONDITION,
         RESERVED_DATA_TYPE,

         // LITERALS
         LITERAL_HEXA,
         LITERAL_FLOAT,
         LITERAL_OCTAL,
         LITERAL_STRING,
         LITERAL_DECIMAL,
         LITERAL_CHARACTER,
         LITERAL_EXPONENTIAL_FLOAT,

         // OPERATORS
         OPERATOR_INC,
         OPERATOR_DEC,
         OPERATOR_ADD,
         OPERATOR_DOT,
         OPERATOR_MATH,
         OPERATOR_MEMORY,
         OPERATOR_DIVIDE,
         OPERATOR_BINARY,
         OPERATOR_BRACKET,
         OPERATOR_BOOLEAN,
         OPERATOR_END_LINE,
         OPERATOR_NEGATIVE,
         OPERATOR_SEPARATE,
         OPERATOR_MULTIPLY,
         OPERATOR_REMAINDER,
         OPERATOR_ASSIGNMENT,
         OPERATOR_L_SHIFT_EQ,
         OPERATOR_R_SHIFT_EQ,
         OPERATOR_BITWISE_OR,
         OPERATOR_SQ_BRACKET,
         OPERATOR_PARENTHESIS_L,
         OPERATOR_PARENTHESIS_R,
         OPERATOR_MULTIPLY_EQ,
         OPERATOR_CONTINUE_LINE,
         OPERATOR_BITWISE_AND,
         OPERATOR_BITWISE_EXCLUSIVE_OR,
         OPERATOR_COMPARATIVE,
         OPERATOR_NOT,
         BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, ELSE, FOR, IF , RETURN, SHORT, SWITCH, VOID, WHILE, READ, WRITE, IDENTIFIER,
         INT, LONG;



non terminal initial;
non terminal valid_name;
non terminal var_declarations, var_declaration, var_expression, var_type, var_type_declaration;
non terminal expression;

start with initial;

initial ::=
    var_declarations OPERATOR_NOT |
    OPERATOR_NOT
;

// VARIABLES
var_declarations ::=
    var_declarations var_declaration |
    var_declaration
;

var_declaration ::=
    var_expression OPERATOR_END_LINE |
    // Errors
    var_expression {: System.out.println("Missing ;"); :}
;

var_expression ::=
    var_type_declaration OPERATOR_ASSIGNMENT expression |
    var_type_declaration |
    // Errors
    var_type_declaration OPERATOR_ASSIGNMENT {: System.out.println("Missing expression after assignment"); :}
;

var_type_declaration ::=
    var_type valid_name |
    valid_name {: System.out.println("Missing data type"); :}
;

var_type ::=
    LONG | INT | SHORT | CHAR
;

valid_name ::=
    IDENTIFIER | IDENTIFIER_ERROR // Recovers from lexical error
;

// EXPRESSIONS TO EVALUATE
expression ::=
    OPERATOR_DOT
;
