package Parser; 
import java.util.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import Semantic.*;
import java.util.HashMap;

import Parser.Error.*;

parser code
{:

    private Symbol currentSymbol;
    private Symbol previousSymbol;
    private Boolean generateASMFlag;
    private ArrayList<String> listaErroresSemanticos = new ArrayList<String>();
    private PilaSemantica pila = new PilaSemantica();
    public HashMap<String, DataObject> tablaSimbolos = new HashMap<String, DataObject>();


    public Symbol getCurrentSymbol(){
        return this.currentSymbol;
    }

     public void syntax_error(Symbol s){
        syntaxerrors.add(new SyntaxError(ErrorTypes.UNEXPECTED_ERROR, s.right + 1, s.left + 1));
        //System.out.println("Error R de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }
    public void addError(String error){
        this.listaErroresSemanticos.push(error+" Linea "+(s.right+1)+" columna "+(s.left+1)+"\n");
    }
    public void unrecovered_syntax_error(Symbol s){
        //System.out.println("Error NR de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }

    private ArrayList<SyntaxError> syntaxerrors = new ArrayList<SyntaxError>();

    @Override
    public String toString() {
        String result = "";

        if (!syntaxerrors.isEmpty()) {
            result += "====== Syntax Errors ======\n";

            for (int i = 0; i < syntaxerrors.size(); i++) {
                SyntaxError error = syntaxerrors.get(i);
                if (!(error.getLine() == 0)) result += error.toString();
            }
        }
        return result;
    }

    public void newSyntaxError(ErrorTypes pType) {
        syntaxerrors.add(new SyntaxError(pType, previousSymbol.right + 1, previousSymbol.left + previousSymbol.toString().length()));
    }

    public PilaSemantica getPila() {
        return this.pila;
    }

    public HashMap<String, DataObject> getTabla() {
        return this.tablaSimbolos;
    }

:};

scan with {:
        if (currentSymbol != null) this.previousSymbol = currentSymbol;
        this.currentSymbol = this.getScanner().next_token();
        return currentSymbol;
:};


terminal
        IDENTIFIER_ERROR,
         // RESERVED WORDS
         RESERVED_DATA_TYPE,

         // LITERALS
         LITERAL_HEXA,
         LITERAL_FLOAT,
         LITERAL_OCTAL,
         LITERAL_STRING,
         LITERAL_DECIMAL,
         LITERAL_CHARACTER,
         LITERAL_EXPONENTIAL_FLOAT,

         // OPERATORS
         OPERATOR_INC,
         OPERATOR_DEC,
         OPERATOR_ADD,
         OPERATOR_DIVIDE,
         OPERATOR_BRACKET_L,
         OPERATOR_BRACKET_R,
         OPERATOR_END_LINE,
         OPERATOR_NEGATIVE,
         OPERATOR_SEPARATE,
         OPERATOR_MULTIPLY,
         OPERATOR_REMAINDER,
         OPERATOR_ASSIGNMENT,
         OPERATOR_ASSIGNMENT_EQUALS,
         OPERATOR_SQ_BRACKET_L,
         OPERATOR_SQ_BRACKET_R,
         OPERATOR_PARENTHESIS_L,
         OPERATOR_PARENTHESIS_R,
         OPERATOR_COMPARATIVE,
         OPERATOR_NOT,
         OPERATOR_COLON,
         BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, ELSE, FOR, IF , RETURN, SHORT, SWITCH, VOID, WHILE, READ, WRITE, IDENTIFIER,
         INT, LONG;



non terminal initial;
non terminal valid_name, data_type, typed_identifier, assignments;
non terminal var_declarations, var_declaration, var_expression, var_list_brackets, literals, valid_statement, inc_dec, math;

non terminal func_declarations, func_declaration, func_decl_parentheses, statement, func_call_parentheses, parameter, statements;

non terminal expression, expressions, list_expression, error_terminal_tokens;

non terminal switch, read_write, switch_inside;

non terminal case_expressions, case_expression, assignment_expression;

non terminal switch_data_type, missing_expression, var_identifiers;

non terminal while_expression, for_expression, if_expression, else_expression, brackets;

non terminal for_variable, loop_words, for_loop;

non terminal var_list_errors, var_list_types;

precedence left OPERATOR_COMPARATIVE;
precedence left OPERATOR_ADD, OPERATOR_NEGATIVE;
precedence left OPERATOR_MULTIPLY, OPERATOR_DIVIDE, OPERATOR_REMAINDER;

precedence left OPERATOR_INC, OPERATOR_DEC;

precedence right IDENTIFIER, IDENTIFIER_ERROR;

start with initial;

initial ::=
    var_declarations func_declarations |
    func_declarations |
    error error_terminal_tokens
;

for_loop ::=
    for_expression brackets |
    for_expression OPERATOR_END_LINE
;

for_expression ::=
    FOR OPERATOR_PARENTHESIS_L for_variable expression OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable valid_name assignments expression OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable OPERATOR_END_LINE expression OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable expression OPERATOR_END_LINE OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable valid_name assignments expression OPERATOR_END_LINE OPERATOR_PARENTHESIS_R |
    FOR OPERATOR_PARENTHESIS_L for_variable OPERATOR_END_LINE OPERATOR_PARENTHESIS_R
;

for_variable ::=
    data_type valid_name OPERATOR_ASSIGNMENT_EQUALS expression OPERATOR_END_LINE|
    valid_name OPERATOR_ASSIGNMENT_EQUALS expression OPERATOR_END_LINE|
    valid_name OPERATOR_END_LINE |
    OPERATOR_END_LINE
;

// VARIABLES
var_declarations ::=
    var_declarations var_declaration |
    var_declaration
;

var_declaration ::=
    var_expression  OPERATOR_END_LINE

    {:

        RegistroTipo registro = (RegistroTipo) this.parser.pila.buscarRegistro(Registros.TIPO);
        while(this.parser.pila.peek() != registro) {
            RegistroIdentificador registroActual = (RegistroIdentificador) this.parser.pila.pop();

            if (this.parser.tablaSimbolos.get(registroActual.getToken()) != null) {
                System.out.println("Variable ya ha sido declarada: " + registroActual.getToken());
            } else {
                this.parser.tablaSimbolos.put(registroActual.getToken(), new DataObject(registro.getToken(), registroActual.getToken()));
            }

        }
        this.parser.pila.pop();
    :}

    |
    // Errors
    var_expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    error data_type |
    error VOID
;



var_expression ::=
    data_type var_identifiers |
    CONST data_type var_identifiers OPERATOR_ASSIGNMENT_EQUALS expression |
    typed_identifier var_list_brackets |
    CONST typed_identifier var_list_brackets  OPERATOR_ASSIGNMENT_EQUALS list_expression
;

var_identifiers ::=
    var_identifiers OPERATOR_SEPARATE valid_name |
    valid_name |
    var_identifiers valid_name {: newSyntaxError(ErrorTypes.MISSING_SEPARATOR); :}
;

var_list_brackets ::=
    OPERATOR_SQ_BRACKET_L LITERAL_DECIMAL OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L var_list_types OPERATOR_SQ_BRACKET_R {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    var_list_errors {: newSyntaxError(ErrorTypes.MISSING_SQUARE_BRACKETS); :}
;

var_list_errors ::=
    OPERATOR_SQ_BRACKET_L LITERAL_DECIMAL |
    OPERATOR_SQ_BRACKET_L |
    OPERATOR_SQ_BRACKET_R |
    LITERAL_DECIMAL OPERATOR_SQ_BRACKET_R |
    OPERATOR_SQ_BRACKET_L var_list_types {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    var_list_types OPERATOR_SQ_BRACKET_L {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :}
;

var_list_types ::=
   LITERAL_FLOAT | LITERAL_STRING | LITERAL_CHARACTER | LITERAL_EXPONENTIAL_FLOAT
;

// FUNCTIONS
func_declarations ::=
    func_declarations func_declaration |
    func_declaration
;

func_declaration ::=
    typed_identifier func_decl_parentheses brackets  |
    typed_identifier func_decl_parentheses  OPERATOR_END_LINE  |
    VOID valid_name func_decl_parentheses brackets |
    VOID valid_name func_decl_parentheses  OPERATOR_END_LINE
;

brackets ::=
    OPERATOR_BRACKET_L var_declarations statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L var_declarations OPERATOR_BRACKET_R
;

statements ::=
    statements statement |
    statement

;

statement  ::=
    valid_statement OPERATOR_END_LINE |
    while_expression |
    for_loop |
    switch |
    if_expression |
    valid_name assignments expression OPERATOR_END_LINE {:
        RegistroConstante registro = (RegistroConstante) this.parser.pila.pop();
        RegistroOperador registroOperador = (RegistroOperador) this.parser.pila.pop();
        if (registroOperador.getToken() == "=") {
            RegistroIdentificador registroIdentificador = (RegistroIdentificador) this.parser.pila.pop();
            if (this.parser.tablaSimbolos.get(registroIdentificador.getToken()) == null) {
                addError("Identificador no encontrado");
            }
        } else {

        }
    :}
    |
    valid_name OPERATOR_ASSIGNMENT_EQUALS list_expression OPERATOR_END_LINE |
    brackets |
    loop_words OPERATOR_END_LINE |
    RETURN expression OPERATOR_END_LINE |

    // Read | Write
    read_write OPERATOR_END_LINE |

    // Errors
    valid_statement {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :}  |
    valid_name assignments expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    loop_words  {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    RETURN expression {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    read_write {: newSyntaxError(ErrorTypes.MISSING_SEMICOLON); :} |
    error error_terminal_tokens
;

error_terminal_tokens ::=
    OPERATOR_END_LINE |
    OPERATOR_BRACKET_R
;

read_write ::=
   READ OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |
   READ OPERATOR_PARENTHESIS_L valid_name OPERATOR_PARENTHESIS_R |
   WRITE OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R
;

valid_statement ::=
    valid_name func_call_parentheses |
    valid_name inc_dec |
    inc_dec valid_name
;

func_call_parentheses ::=
    OPERATOR_PARENTHESIS_L expressions OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R
;

func_decl_parentheses ::=
    OPERATOR_PARENTHESIS_L parameter OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |

    // Errores
    OPERATOR_PARENTHESIS_L parameter {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :}|
    OPERATOR_PARENTHESIS_L {: newSyntaxError(ErrorTypes.MISSING_PARENTHESES); :}
;

expressions ::=
    expressions OPERATOR_SEPARATE expression |
    expression
;

parameter ::=
    parameter OPERATOR_SEPARATE typed_identifier |
    typed_identifier |
    CONST typed_identifier |
    literals {: newSyntaxError(ErrorTypes.FUNCTION_DECLARATION_ERROR); :}
;

list_expression ::=
    OPERATOR_BRACKET_L expressions OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R
;

assignments ::=
    OPERATOR_ASSIGNMENT | OPERATOR_ASSIGNMENT_EQUALS:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
;

// El swith puede contener cero o mas cases, y cero o un default
switch ::=
    SWITCH OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R switch_inside |
    SWITCH missing_expression switch_inside
;

switch_inside ::=
    OPERATOR_BRACKET_L case_expressions DEFAULT OPERATOR_COLON expression OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L DEFAULT OPERATOR_COLON expression OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L case_expressions OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R
;

missing_expression ::=
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R {: newSyntaxError(ErrorTypes.MISSING_EXPRESSION); :}
;

//Esto se utiliza para poder tener uno o mas cases dentro del swtich
case_expressions ::=
    case_expressions case_expression |
    case_expression |
    error OPERATOR_END_LINE {: newSyntaxError(ErrorTypes.CASE_ERROR); :}
;

// Esto seria la expresion case del switch, la cual tiene como estructura minima el case, un dato entero o caracter y dos puntos.
// tambien puede traer una expresion y/o break
case_expression ::=
    CASE switch_data_type OPERATOR_COLON var_declarations statements |
    CASE switch_data_type OPERATOR_COLON statements |
    CASE switch_data_type OPERATOR_COLON var_declarations |
    CASE switch_data_type OPERATOR_COLON
;

//case_expression_error ::=
//    CASE OPERATOR_COLON {: newSyntaxError(ErrorTypes.MISSING_EXPRESSION); :} |
//    CASE switch_data_type {: newSyntaxError(ErrorTypes.MISSING_COLON); :}
//    //CASE switch_data_type OPERATOR_COLON var_declarations statements var_declaration {: newSyntaxError(ErrorTypes.VARIABLE_DECLARATION_ERROR); :} |
//    //CASE switch_data_type OPERATOR_COLON statements var_declaration {: newSyntaxError(ErrorTypes.VARIABLE_DECLARATION_ERROR); :}
//;

// Estos son los tipos de datos que maneja el switch, los cuales son numeros decimales y caracteres
switch_data_type ::=
    LITERAL_DECIMAL |
    LITERAL_FLOAT {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_HEXA |
    LITERAL_OCTAL |
    LITERAL_EXPONENTIAL_FLOAT {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_CHARACTER {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :} |
    LITERAL_STRING {: newSyntaxError(ErrorTypes.INVALID_DATA_TYPE); :}
;


// WHILE
while_expression ::=
    DO brackets WHILE OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R OPERATOR_END_LINE |
    WHILE OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R OPERATOR_END_LINE |
    WHILE OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets |
    // Error
    WHILE missing_expression brackets |
    DO brackets WHILE missing_expression OPERATOR_END_LINE
;

// COMMON PRODUCTIONS
data_type ::=
    LONG:e {: RegistroTipo registro = new RegistroTipo(e.toString()); this.parser.pila.push(registro); :}
    | INT:e {: RegistroTipo registro = new RegistroTipo(e.toString()); this.parser.pila.push(registro); :}
    | SHORT:e {: RegistroTipo registro = new RegistroTipo(e.toString()); this.parser.pila.push(registro); :}
    | CHAR:e {: RegistroTipo registro = new RegistroTipo(e.toString()); this.parser.pila.push(registro); :}
    | RESERVED_DATA_TYPE {: newSyntaxError(ErrorTypes.NOT_SUPPORTED_DATA_TYPE); :}
;

valid_name ::=
    IDENTIFIER:e {: RegistroIdentificador registro = new RegistroIdentificador(e.toString()); this.parser.pila.push(registro); :}
    | IDENTIFIER_ERROR // Recovers from lexical error
;

typed_identifier ::=
    data_type valid_name |
    valid_name {: newSyntaxError(ErrorTypes.MISSING_DATA_TYPE); :}
;

// Construccion del if

if_expression ::=
    IF OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets else_expression |
    IF OPERATOR_PARENTHESIS_L assignment_expression OPERATOR_PARENTHESIS_R brackets |

    // Error
    IF missing_expression brackets else_expression |
    IF missing_expression brackets |
    IF {: newSyntaxError(ErrorTypes.INCOMPLETE_EXPRESSION); :}
;

else_expression ::=
    ELSE if_expression |
    ELSE brackets
;

assignment_expression ::=
    valid_name assignments expression |
    expression
;


expression ::=
    // LOGICAL
    OPERATOR_NOT expression |
    expression OPERATOR_COMPARATIVE expression |

    // MATH
    OPERATOR_NEGATIVE expression |

    expression math expression |


    OPERATOR_PARENTHESIS_L expression OPERATOR_PARENTHESIS_R |

    // FINAL
    literals |
    valid_name |
    valid_statement
;

inc_dec ::=
    OPERATOR_INC | OPERATOR_DEC
;

math ::=
    OPERATOR_ADD:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_NEGATIVE:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_MULTIPLY:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_DIVIDE:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
    | OPERATOR_REMAINDER:e {: RegistroOperador registro = new RegistroOperador(e.toString()); this.parser.pila.push(registro); :}
;

literals ::=
    LITERAL_HEXA:e {: RegistroConstante registro = new RegistroConstante(e.toString(), "HEXA"); this.parser.pila.push(registro); :}
    | LITERAL_OCTAL:e {: RegistroConstante registro = new RegistroConstante(e.toString(), "OCTAL"); this.parser.pila.push(registro); :}
    | LITERAL_STRING:e {: RegistroConstante registro = new RegistroConstante(e.toString(), "STRING"); this.parser.pila.push(registro); :}
    | LITERAL_DECIMAL:e {: RegistroConstante registro = new RegistroConstante(e.toString(), "DECIMAL"); this.parser.pila.push(registro); :}
    | LITERAL_CHARACTER :e {: RegistroConstante registro = new RegistroConstante(e.toString(), "CHARACTER"); this.parser.pila.push(registro); :}
;

loop_words ::=
    BREAK | CONTINUE
;

