package Parser; 
import java.util.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code
{:
    /*
    private Symbol s;

    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
    }
    */
     public void syntax_error(Symbol s){
        System.out.println("Error R de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }

    public void unrecovered_syntax_error(Symbol s){
        System.out.println("Error NR de sintaxis: "+ s.value +" Linea "+(s.right+1)+" columna "+(s.left+1) );
    }
:};


terminal STRING_ERROR,
         UNKNOWN_ERROR,
         COMMENTS_ERROR,
         CHARACTER_ERROR,
         IDENTIFIER_ERROR,
         FLOAT_MANY_DOTS_ERROR,

         // RESERVED WORDS
         RESERVED_LOOP,
         RESERVED_ENUM,
         RESERVED_WORDS,
         RESERVED_MODIFIER,
         RESERVED_CONDITION,
         RESERVED_DATA_TYPE,

         // LITERALS
         LITERAL_HEXA,
         LITERAL_FLOAT,
         LITERAL_OCTAL,
         LITERAL_STRING,
         LITERAL_DECIMAL,
         LITERAL_CHARACTER,
         LITERAL_EXPONENTIAL_FLOAT,

         // OPERATORS
         OPERATOR_INC,
         OPERATOR_DEC,
         OPERATOR_ADD,
         OPERATOR_DOT,
         OPERATOR_MATH,
         OPERATOR_MEMORY,
         OPERATOR_DIVIDE,
         OPERATOR_BINARY,
         OPERATOR_BRACKET_L,
         OPERATOR_BRACKET_R,
         OPERATOR_BOOLEAN,
         OPERATOR_END_LINE,
         OPERATOR_NEGATIVE,
         OPERATOR_SEPARATE,
         OPERATOR_MULTIPLY,
         OPERATOR_REMAINDER,
         OPERATOR_ASSIGNMENT,
         OPERATOR_L_SHIFT_EQ,
         OPERATOR_R_SHIFT_EQ,
         OPERATOR_BITWISE_OR,
         OPERATOR_SQ_BRACKET_L,
         OPERATOR_SQ_BRACKET_R,
         OPERATOR_PARENTHESIS_L,
         OPERATOR_PARENTHESIS_R,
         OPERATOR_MULTIPLY_EQ,
         OPERATOR_CONTINUE_LINE,
         OPERATOR_BITWISE_AND,
         OPERATOR_BITWISE_EXCLUSIVE_OR,
         OPERATOR_COMPARATIVE,
         OPERATOR_NOT,
         BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, ELSE, FOR, IF , RETURN, SHORT, SWITCH, VOID, WHILE, READ, WRITE, IDENTIFIER,
         INT, LONG;



non terminal initial;
non terminal valid_name, data_type, typed_identifier;
non terminal var_declarations, var_declaration, var_expression;

non terminal func_declarations, func_declaration, parentheses, brackets, parameter, statements;

non terminal expression;

non terminal List<Error> errors;

start with initial;

initial ::=
    var_declarations func_declarations |
    func_declarations |
    error:e {: System.out.println("se caio"); :}
;

// VARIABLES
var_declarations ::=
    var_declarations var_declaration |
    var_declaration
;

var_declaration ::=
    var_expression OPERATOR_END_LINE |
    // Errors
    var_expression {: System.out.println("Missing ;"); :}
;

var_expression ::=
    typed_identifier OPERATOR_ASSIGNMENT expression |
    typed_identifier |
    CONST typed_identifier |
    CONST typed_identifier OPERATOR_ASSIGNMENT expression |

    // Errors
    typed_identifier OPERATOR_ASSIGNMENT {: System.out.println("Missing expression after assignment"); :}
;

// EXPRESSIONS TO EVALUATE
expression ::=
    OPERATOR_DOT
;

// FUNCTIONS
func_declarations ::=
    func_declarations func_declaration |
    func_declaration
;

func_declaration ::=
    typed_identifier parentheses brackets  |
    typed_identifier parentheses OPERATOR_END_LINE |
    VOID valid_name parentheses brackets |
    VOID valid_name parentheses OPERATOR_END_LINE
;

brackets ::=
    OPERATOR_BRACKET_L var_declarations statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L statements OPERATOR_BRACKET_R |
    OPERATOR_BRACKET_L OPERATOR_BRACKET_R
;

statements ::=
    statements OPERATOR_NOT |
    OPERATOR_NOT
;

parentheses ::=
    OPERATOR_PARENTHESIS_L parameter OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L OPERATOR_PARENTHESIS_R |
    OPERATOR_PARENTHESIS_L {:  :} |
    OPERATOR_PARENTHESIS_R {:  :}
;

parameter ::=
    parameter OPERATOR_SEPARATE typed_identifier |
    typed_identifier
;

// COMMON PRODUCTIONS
data_type ::=
    LONG | INT | SHORT | CHAR
;

valid_name ::=
    IDENTIFIER | IDENTIFIER_ERROR // Recovers from lexical error
;

typed_identifier ::=
    data_type valid_name |
    valid_name {: System.out.println("Missing data type"); :}
;